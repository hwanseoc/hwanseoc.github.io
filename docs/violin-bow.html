<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bow Torque Calculator</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { color-scheme: dark; }
    code, pre { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    svg { shape-rendering: geometricPrecision; }
  </style>
</head>
<body class="min-h-screen bg-slate-950 text-slate-100 antialiased">
  <div class="max-w-5xl mx-auto px-4 py-8">
    <!-- Header -->
    <header class="flex items-center gap-4 mb-6">
      <div class="w-11 h-11 rounded-xl bg-gradient-to-tr from-sky-500 to-emerald-400 shadow-[0_8px_30px_rgba(56,189,248,0.35)]"></div>
      <div>
        <h1 class="text-2xl font-semibold tracking-tight">Bow Torque Calculator</h1>
      </div>
    </header>

    <!-- Card -->
    <section class="rounded-2xl border border-white/10 bg-white/5 p-5 shadow-xl">
      <div class="space-y-6">
        <!-- Inputs grid: order N, dN, W, dW, dF1, dF4 -->
        <div class="grid grid-cols-12 gap-4 items-end">
          <!-- N with slider + number -->
          <div class="col-span-12 lg:col-span-6">
            <label for="nRange" class="block text-xs text-red-400 mb-1">N (string normal) [N]</label>
            <div class="flex items-center gap-3">
              <input id="nRange" type="range" min="0" max="1.5" step="0.01" value="0.65" class="w-full" />
              <input id="n" type="number" min="0" max="1.5" step="0.01" value="0.65" class="w-28 px-3 py-2 rounded-lg bg-slate-900 border border-white/10" />
            </div>
          </div>

          <!-- dN with slider + number (cm) -->
          <div class="col-span-12 lg:col-span-6">
            <label for="dnRange" class="block text-xs text-red-400 mb-1">dN (thumb → string contact) [cm]</label>
            <div class="flex items-center gap-3">
              <input id="dnRange" type="range" min="0" max="70" step="0.1" value="23" class="w-full" />
              <input id="dn" type="number" min="0" max="70" step="0.1" value="23" class="w-28 px-3 py-2 rounded-lg bg-slate-900 border border-white/10" />
            </div>
          </div>

          <!-- W -->
          <div class="col-span-12 sm:col-span-6 lg:col-span-3">
            <label for="w" class="block text-xs text-gray-400 mb-1">W (bow weight) [N]</label>
            <input id="w" type="number" step="0.01" min="0" value="0.53" class="w-full px-3 py-2 rounded-lg bg-slate-900 border border-white/10" />
          </div>

          <!-- dW -->
          <div class="col-span-12 sm:col-span-6 lg:col-span-3">
            <label for="dw" class="block text-xs text-gray-400 mb-1">dW (thumb → COM) [cm]</label>
            <input id="dw" type="number" step="0.1" min="0.0" value="19" class="w-full px-3 py-2 rounded-lg bg-slate-900 border border-white/10" />
          </div>

          <!-- dF1 -->
          <div class="col-span-12 sm:col-span-6 lg:col-span-3">
            <label for="df1" class="block text-xs text-blue-400 mb-1">dF1 (thumb → index) [cm]</label>
            <input id="df1" type="number" step="0.1" min="0.1" value="3.0" class="w-full px-3 py-2 rounded-lg bg-slate-900 border border-white/10" />
          </div>

          <!-- dF4 -->
          <div class="col-span-12 sm:col-span-6 lg:col-span-3">
            <label for="df4" class="block text-xs text-green-400 mb-1">dF4 (thumb → little) [cm]</label>
            <input id="df4" type="number" step="0.1" min="0.1" value="5.5" class="w-full px-3 py-2 rounded-lg bg-slate-900 border border-white/10" />
          </div>
        </div>

        <!-- Outputs -->
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
          <div class="rounded-xl border border-white/10 bg-slate-900 p-4 text-center">
            <h3 class="text-xs text-blue-400 mb-1">F1 (index) [N]</h3>
            <div id="outF1" class="text-2xl font-bold tracking-tight">0.0000</div>
          </div>
          <div class="rounded-xl border border-white/10 bg-slate-900 p-4 text-center">
            <h3 class="text-xs text-orange-400 mb-1">T (thumb) [N]</h3>
            <div id="outT" class="text-2xl font-bold tracking-tight">0.0000</div>
          </div>
          <div class="rounded-xl border border-white/10 bg-slate-900 p-4 text-center">
            <h3 class="text-xs text-green-400 mb-1">F4 (little) [N]</h3>
            <div id="outF4" class="text-2xl font-bold tracking-tight">0.0000</div>
          </div>
        </div>

        <!-- Visualization: vertical forces along the bow -->
        <div class="rounded-2xl border border-white/10 bg-slate-900 p-4">
          <svg id="forceSvg" class="w-full h-80"></svg>
        </div>

        <!-- Equations (plaintext) -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-3">
          <div class="rounded-xl border border-dashed border-white/10 bg-slate-900 p-4">
            <div class="text-sky-300 mb-2">Model</div>
            <pre class="text-[13px] whitespace-pre-wrap">
              <code>
minimize F1 + F4 + T

N + T = W + F1 + F4

dN * N - dW * W - dF1 * F1 + dF4 * F4 = 0
              </code>
            </pre>
          </div>
          <div class="rounded-xl border border-dashed border-white/10 bg-slate-900 p-4">
            <div class="text-sky-300 mb-2">Algorithm (optimal)</div>
            <pre class="text-[13px] whitespace-pre-wrap">
              <code>
Let K = dW*W - dN*N.
Assume dF1>0 and dF4>0.

F1* = max( 0,
          -K/dF1,
          (dF4*(N - W) - K)/(dF4 + dF1) )
F4* = (K + dF1*F1*)/dF4
T*  = W + F1* + F4* - N
              </code>
            </pre>
          </div>
        </div>

        <!-- Expanded with numbers and checks -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-3">
          <div class="rounded-xl border border-dashed border-white/10 bg-slate-900 p-4">
            <div class="text-sky-300 mb-2">Expanded torque</div>
            <pre id="eqExpanded" class="text-[13px] whitespace-pre-wrap"></pre>
          </div>
          <div class="rounded-xl border border-dashed border-white/10 bg-slate-900 p-4">
            <div class="text-sky-300 mb-2">Checks</div>
            <pre id="checks" class="text-[13px] whitespace-pre-wrap"></pre>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    const $ = (s) => document.querySelector(s);

    // Sync handlers
    $('#nRange').addEventListener('input', (e) => { $('#n').value = e.target.value; compute(); });
    $('#n').addEventListener('input', (e) => { $('#nRange').value = e.target.value; compute(); });

    $('#dnRange').addEventListener('input', (e) => { const v = fmt1(e.target.value); $('#dn').value = v; $('#dnRange').value = v; compute(); });
    $('#dn').addEventListener('input', (e) => { const v = fmt1(e.target.value); $('#dn').value = v; $('#dnRange').value = v; compute(); });

    // W stays free; distances show one decimal
    document.getElementById('w').addEventListener('input', compute);
    ['dw','df1','df4'].forEach(id => {
      const el = document.getElementById(id);
      el.addEventListener('input', (e) => {
        const v = fmt1(e.target.value);
        e.target.value = v;
        compute();
      });
    });

    function num(id){ return parseFloat(document.getElementById(id).value || '0'); }

    function clampSmall(x, eps=1e-12){ return Math.abs(x) < eps ? 0 : x; }

    // Format helper for distances
    function fmt1(x){ const v = parseFloat(x); return Number.isFinite(v) ? v.toFixed(1) : '0.0'; }

    function compute(){
      const N   = num('n');
      const W   = num('w');
      const dN  = num('dn');
      const dW  = num('dw');
      let dF1 = num('df1');
      let dF4 = num('df4');

      // Guard: enforce strictly positive lever arms for the formula
      const EPS = 0.1;
      dF1 = dF1 <= 0 ? EPS : dF1;
      dF4 = dF4 <= 0 ? EPS : dF4;

      // Constants
      const K = dW * W - dN * N;

      // Lower bounds for F1
      const lb0 = 0;
      const lbF4pos = -K / dF1; // ensures F4 >= 0
      const lbTpos  = (dF4 * (N - W) - K) / (dF4 + dF1); // ensures T >= 0

      // Optimal F1
      let F1 = Math.max(lb0, lbF4pos, lbTpos);
      // Derived F4 and T
      let F4 = (K + dF1 * F1) / dF4;
      let T  = W + F1 + F4 - N;

      // Numerical hygiene: clamp tiny negatives
      F1 = Math.max(0, clampSmall(F1));
      F4 = Math.max(0, clampSmall(F4));
      T  = Math.max(0, clampSmall(T));

      // Outputs
      $('#outF1').textContent = F1.toFixed(4);
      $('#outF4').textContent = F4.toFixed(4);
      $('#outT').textContent  = T.toFixed(4);

      // Expanded torque with numbers
      $('#eqExpanded').textContent = `dN * N - dW * W - dF1 * F1 + dF4 * F4 = 0\n` + `${dN.toFixed(2)} * ${N.toFixed(2)} - ${dW.toFixed(2)} * ${W.toFixed(2)} - ${dF1.toFixed(2)} * ${F1.toFixed(4)} + ${dF4.toFixed(2)} * ${F4.toFixed(4)} = 0\n` + `${(dN*N).toFixed(4)} - ${(dW*W).toFixed(4)} - ${(dF1*F1).toFixed(4)} + ${(dF4*F4).toFixed(4)} = 0`;

      // Checks
      const verticalLeft  = (N + T);
      const verticalRight = (W + F1 + F4);
      const torqueLeft    = (dN*N - dW*W - dF1*F1 + dF4*F4);

      function nearlyEqual(a, b, eps = 1e-6){ return Math.abs(a - b) <= eps; }
      const vertical_ok = nearlyEqual(verticalLeft, verticalRight);
      const torque_ok   = nearlyEqual(torqueLeft, 0);
      $('#checks').textContent = `Vertical: N + T = ${verticalLeft.toFixed(4)}  vs  W + F1 + F4 = ${verticalRight.toFixed(4)}  =>  ${vertical_ok ? 'OK' : 'FAIL'}\n` + `Torque: dN*N - dW*W - dF1*F1 + dF4*F4 = ${torqueLeft.toFixed(6)}  =>  ${torque_ok ? 'OK' : 'FAIL'}`;

      // Draw visualization
      drawForces({ N, W, dN, dW, dF1, dF4, F1, F4, T });
    }

    function drawForces({ N, W, dN, dW, dF1, dF4, F1, F4, T }){
      const svg = document.getElementById('forceSvg');
      if (!svg) return;

      // Clear
      while(svg.firstChild) svg.removeChild(svg.firstChild);

      // Signed positions per spec (cm): left negative, right positive
      let xN  = -dN;
      let xW  = -dW;
      let xF1 = -dF1;
      let xF4 = +dF4;
      const xThumb = 0;

      // Clamp to visible axis [-70, +10] cm
      const AX_MIN = -70, AX_MAX = +10, AX_SPAN = AX_MAX - AX_MIN; // 90 cm
      xN = Math.max(AX_MIN, Math.min(AX_MAX, xN));
      xW = Math.max(AX_MIN, Math.min(AX_MAX, xW));
      xF1 = Math.max(AX_MIN, Math.min(AX_MAX, xF1));
      xF4 = Math.max(AX_MIN, Math.min(AX_MAX, xF4));

      // Size
      const width = svg.clientWidth || 800;
      const height = svg.clientHeight || 320;
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

      // Map cm → px using fixed axis
      const margin = 36;
      const innerW = Math.max(50, width - 2*margin);
      const sx = innerW / AX_SPAN;
      const x = (cm) => margin + (cm - AX_MIN) * sx;

      // Forces → arrow lengths (N → px), fixed scale so visual lengths track absolute values across sliders
      const sy = 40; // px per Newton (fixed)

      const y0 = Math.round(height / 2); // baseline (bow axis)

      // Helpers
      const ns = 'http://www.w3.org/2000/svg';
      const append = (el) => svg.appendChild(el);
      const make = (name, attrs={}) => { const e = document.createElementNS(ns, name); for(const k in attrs){ e.setAttribute(k, attrs[k]); } return e; };

      // Colors
      const C = { N:'#ef4444', W:'#9ca3af', F1:'#3b82f6', F4:'#22c55e', T:'#f97316', tick:'#475569', base:'#94a3b8' };

      // Baseline fixed from -80 to +10
      append(make('line', { x1: x(AX_MIN), y1: y0, x2: x(AX_MAX), y2: y0, stroke:C.base, 'stroke-width':'2' }));

      for(let cm = Math.ceil(AX_MIN / 10) * 10; cm <= AX_MAX; cm += 10){
        const xc = x(cm);
        append(make('line', { x1: xc, y1: y0 - 8, x2: xc, y2: y0 + 8, stroke: C.tick, 'stroke-width': '1' }));
      }

      // Thumb reference mark at 0 cm
      append(make('circle', { cx: x(xThumb), cy: y0, r: '4', fill: C.T }));

      // Arrow utility that starts at signed offset and ends at the baseline
      function arrowToBaseline(xc, signedLen, color, label, labelOffsetSign=1, preferFromBelow=false){
        const mag = Math.abs(signedLen);
        const headH = 8; // px
        const headW = 6; // px
        // Choose direction: by sign; if zero use preferred
        const fromBelow = signedLen > 0 ? true : (signedLen < 0 ? false : !!preferFromBelow);
        // Tail only if nonzero
        if(mag > 0){
          const yTail = fromBelow ? (y0 + mag) : (y0 - mag);
          const yShaftEnd = fromBelow ? (y0 + headH) : (y0 - headH);
          append(make('line', { x1: xc, y1: yTail, x2: xc, y2: yShaftEnd, stroke: color, 'stroke-width': '2' }));
        }
        // Always draw head with tip at baseline so zero forces still show location
        const points = fromBelow ? `${xc},${y0} ${xc - headW/2},${y0 + headH} ${xc + headW/2},${y0 + headH}` : `${xc},${y0} ${xc - headW/2},${y0 - headH} ${xc + headW/2},${y0 - headH}`;
        append(make('polygon', { points, fill: color }));
        if (label){
          const labelOffset = 16;
          const labelY = y0 + labelOffsetSign * labelOffset;
          const text = make('text', { x: xc, y: labelY, 'text-anchor': 'middle', fill: color, 'font-size': '12', 'font-weight': '600' });
          text.textContent = label;
          append(text);
        }
      }

      arrowToBaseline(x(xW),   -W * sy, C.W, 'W',  1, false);
      arrowToBaseline(x(xN),    N * sy, C.N, 'N', -1, true);
      arrowToBaseline(x(xF1),  -F1 * sy, C.F1, 'F1',  1, false);
      arrowToBaseline(x(xThumb), T * sy, C.T, 'T', -1, true);
      arrowToBaseline(x(xF4),  -F4 * sy, C.F4, 'F4',  1, false);
    }

    // Initial renders for correct sizing
    document.addEventListener('DOMContentLoaded', () => {
      // normalize distance displays to one decimal at start
      ['dn','dw','df1','df4'].forEach(id => {
        const el = document.getElementById(id);
        if(el) el.value = fmt1(el.value);
      });
      ['dnRange'].forEach(id => {
        const el = document.getElementById(id);
        if(el) el.value = fmt1(el.value);
      });
      compute();
      requestAnimationFrame(compute);
    });
    window.addEventListener('load', compute);
    window.addEventListener('resize', compute);
    if (window.ResizeObserver){
      const ro = new ResizeObserver(() => compute());
      const svg = document.getElementById('forceSvg');
      if (svg) ro.observe(svg);
    }
  </script>
</body>
</html>

